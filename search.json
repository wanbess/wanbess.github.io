[{"title":"redis之ziplist","url":"/posts/42240f40.html","content":"<h2 id=\"一，概述\"><a href=\"#一，概述\" class=\"headerlink\" title=\"一，概述\"></a>一，概述</h2><p>ziplist是一种特殊的数据结构，它将链式的数据排列成内存中连续空间，并通过相应的编码形式实现了高效的内存压缩。在原理上，ziplist像是链表和线性数组的一种综合。</p>\n<p>ziplist能存储字符串和整数，对于整数的编码，ziplist采用将其编码成实际的数字而不是字符系列。它允许实现stack类似的push 和 pop操作。时间复杂度为O(1)，但实际中由于需要对内存的再分配，所以近似时间复杂度为O(N)。</p>\n<h2 id=\"二，基本结构\"><a href=\"#二，基本结构\" class=\"headerlink\" title=\"二，基本结构\"></a>二，基本结构</h2><p>ziplist的内部结构从头到尾包含以下几个部分： zlbytes  zltail zllen entry zlend   </p>\n<h3 id=\"zlbytes\"><a href=\"#zlbytes\" class=\"headerlink\" title=\"zlbytes\"></a>zlbytes</h3><p>是一个无符号整型，代表整个ziplist结构所占内存的大小。能再O(1)时间内取得并修改ziplist的大小。</p>\n<h3 id=\"zltail\"><a href=\"#zltail\" class=\"headerlink\" title=\"zltail\"></a>zltail</h3><p>zltail是最后一个entry相对于ziplist起始位置的偏移量。存储这个参数是为了在O(1)时间复杂度内找到最后一个ziplist存储的元素，并进行push和pop操作。</p>\n<h3 id=\"zllen\"><a href=\"#zllen\" class=\"headerlink\" title=\"zllen\"></a>zllen</h3><p>zllen记录了整个ziplist记录的条目(entry)的数量，值得注意的是当这个值比(1&lt;&lt;16)-2大时，需要完整遍历一遍ziplist才能得到真实的长度，zllen只有2个字节长度。</p>\n<h3 id=\"zlend\"><a href=\"#zlend\" class=\"headerlink\" title=\"zlend\"></a>zlend</h3><p>一个特殊的标记，用来表明ziplist的结尾，值为255(0xFF)。</p>\n<h3 id=\"entry\"><a href=\"#entry\" class=\"headerlink\" title=\"entry\"></a>entry</h3><p>entry是ziplist中存储数据的实体，每个entry的开头都包含两部分信息：前一个entry长度的编码和当前entry的编码信息，并且均有各自的编码方式。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zlentry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> prevrawlensize, prevrawlen;<span class=\"comment\">//上个entry长度</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> lensize, len;<span class=\"comment\">//当前entry长度</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> headersize;<span class=\"comment\">//entry的header长度，用p+headersize可得到存储数据的起始地址</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> encoding;<span class=\"comment\">//编码方式</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p;<span class=\"comment\">//当前entry的起始地址</span></span><br><span class=\"line\">&#125; zlentry;</span><br></pre></td></tr></table></figure>\n\n<p>对于上一个entry的长度，有两种情况：若长度小于254字节，则该长度用8bit无符号整数表示，则只需要一个字节；若长度大于等于254字节，则该长度用5个字节表示，其中第一个字节置为254表示这个整数编码，其余4个字节用来记录实际长度。</p>\n<p>对于当前entry的长度编码，则根据当前存储的内容而不同。如果存储的是整数，则前两位置为“11”，其余位代表实际长度；如果存储的是字符串，前两位表示位相应的编码方式，其他位代表实际的长度。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">编码方式</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">00XXXXXX</td>\n<td align=\"center\">字符串长度小于等于63</td>\n</tr>\n<tr>\n<td align=\"center\">01XXXXXX | XXXXXXXX</td>\n<td align=\"center\">字符串长小于等于16383</td>\n</tr>\n<tr>\n<td align=\"center\">10_ _ _ _ _ _ |XXXXXXXX| RRRRRRRR|KKKKKKKKK</td>\n<td align=\"center\">字符串长度大于16383</td>\n</tr>\n<tr>\n<td align=\"center\">11000000</td>\n<td align=\"center\">int16整数</td>\n</tr>\n<tr>\n<td align=\"center\">11010000</td>\n<td align=\"center\">int32整数</td>\n</tr>\n<tr>\n<td align=\"center\">11100000</td>\n<td align=\"center\">int64整数</td>\n</tr>\n<tr>\n<td align=\"center\">11110000</td>\n<td align=\"center\">24bit有符号整数</td>\n</tr>\n<tr>\n<td align=\"center\">11111110</td>\n<td align=\"center\">8bit有符号整数</td>\n</tr>\n<tr>\n<td align=\"center\">1111XXXX(XXXX介于0000和1101之间)</td>\n<td align=\"center\">无符号的0-12整数，0对应0001，1101对应12</td>\n</tr>\n</tbody></table>\n<p>​                                                                          表一：ziplist中entry编码方式</p>\n<p> 例子： 若此时encoding部分为 00000100 ，表示这是个字符串，且长度为4。</p>\n<h2 id=\"三，源码分析\"><a href=\"#三，源码分析\" class=\"headerlink\" title=\"三，源码分析\"></a>三，源码分析</h2><p>ziplist.h提供了一些基本接口供外部调用，下面列出一些常用的函数接口。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistNew</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistPush</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *s, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> slen, <span class=\"type\">int</span> where)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistIndex</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">int</span> index)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistNext</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistPrev</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title function_\">ziplistGet</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> **sval, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> *slen, <span class=\"type\">long</span> <span class=\"type\">long</span> *lval)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistInsert</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *s, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> slen)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistDelete</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> **p)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistDeleteRange</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> index, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> num)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title function_\">ziplistCompare</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *s, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> slen)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistFind</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *vstr, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> vlen, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> skip)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title function_\">ziplistLen</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>除了这些常用API，还有一些内部用于编码和解码的函数和宏。</p>\n<h3 id=\"1，编码相关\"><a href=\"#1，编码相关\" class=\"headerlink\" title=\"1，编码相关\"></a>1，编码相关</h3><p>   ziplist内部操作涉及了很多数据的解压和编码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title function_\">zipPrevEncodeLength</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> len)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (len &lt; ZIP_BIGLEN) ? <span class=\"number\">1</span> : <span class=\"keyword\">sizeof</span>(len)+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len &lt; ZIP_BIGLEN) &#123;</span><br><span class=\"line\">            p[<span class=\"number\">0</span>] = len;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            p[<span class=\"number\">0</span>] = ZIP_BIGLEN;</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(p+<span class=\"number\">1</span>,&amp;len,<span class=\"keyword\">sizeof</span>(len));</span><br><span class=\"line\">            memrev32ifbe(p+<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>+<span class=\"keyword\">sizeof</span>(len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>zipPrevEncodeLength()对prelen长度进行编码，存储到p的header中。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title function_\">zipEncodeLength</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> encoding, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> rawlen)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> len = <span class=\"number\">1</span>, buf[<span class=\"number\">5</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rawlen &lt;= <span class=\"number\">0x3f</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!p) <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">            buf[<span class=\"number\">0</span>] = ZIP_STR_06B | rawlen;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rawlen &lt;= <span class=\"number\">0x3fff</span>) &#123;</span><br><span class=\"line\">            len += <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!p) <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">            buf[<span class=\"number\">0</span>] = ZIP_STR_14B | ((rawlen &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0x3f</span>);</span><br><span class=\"line\">            buf[<span class=\"number\">1</span>] = rawlen &amp; <span class=\"number\">0xff</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            len += <span class=\"number\">4</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!p) <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">            buf[<span class=\"number\">0</span>] = ZIP_STR_32B;</span><br><span class=\"line\">            buf[<span class=\"number\">1</span>] = (rawlen &gt;&gt; <span class=\"number\">24</span>) &amp; <span class=\"number\">0xff</span>;</span><br><span class=\"line\">            buf[<span class=\"number\">2</span>] = (rawlen &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0xff</span>;</span><br><span class=\"line\">            buf[<span class=\"number\">3</span>] = (rawlen &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0xff</span>;</span><br><span class=\"line\">            buf[<span class=\"number\">4</span>] = rawlen &amp; <span class=\"number\">0xff</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!p) <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">        buf[<span class=\"number\">0</span>] = encoding;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(p,buf,len);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>zipEncodeLength()函数对当前entry进行编码，若是字符串编码，根据rawlen可以分为三类：长度小于等于63，小于等于16383，长度大于16383，具体编码方式参考表一；若是整数编码则不做处理，因为所有的整数编码只占一个字节，并且encoding已经在之前zipTryEncoding()中设置了。代码的实现中是通过一个先将rawlen编码写到buf的中间数组，再将buf复制到p。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">zipTryEncoding</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *entry, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> entrylen, <span class=\"type\">long</span> <span class=\"type\">long</span> *v, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *encoding)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (entrylen &gt;= <span class=\"number\">32</span> || entrylen == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (string2ll((<span class=\"type\">char</span>*)entry,entrylen,&amp;value)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value &gt;= <span class=\"number\">0</span> &amp;&amp; value &lt;= <span class=\"number\">12</span>) &#123;</span><br><span class=\"line\">            *encoding = ZIP_INT_IMM_MIN+value;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value &gt;= INT8_MIN &amp;&amp; value &lt;= INT8_MAX) &#123;</span><br><span class=\"line\">            *encoding = ZIP_INT_8B;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value &gt;= INT16_MIN &amp;&amp; value &lt;= INT16_MAX) &#123;</span><br><span class=\"line\">            *encoding = ZIP_INT_16B;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value &gt;= INT24_MIN &amp;&amp; value &lt;= INT24_MAX) &#123;</span><br><span class=\"line\">            *encoding = ZIP_INT_24B;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value &gt;= INT32_MIN &amp;&amp; value &lt;= INT32_MAX) &#123;</span><br><span class=\"line\">            *encoding = ZIP_INT_32B;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            *encoding = ZIP_INT_64B;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        *v = value;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>zipTryEncoding()实现对指定entry的整数编码的尝试，只有能转换成32为</p>\n<p>对于编码entry的流程，首先是通过zipTryEncoding()判断能否进行整数编码，然后是通过zipPrevEncodeLength()对prelen进行编码，最后通过zipEncodeLength()对当前entry进行编码。</p>\n<h3 id=\"2，解码相关\"><a href=\"#2，解码相关\" class=\"headerlink\" title=\"2，解码相关\"></a>2，解码相关</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIP_ENTRY_ENCODING(ptr, encoding) do &#123;  \\</span></span><br><span class=\"line\"><span class=\"meta\">    (encoding) = (ptr[0]); \\</span></span><br><span class=\"line\"><span class=\"meta\">    <span class=\"keyword\">if</span> ((encoding) &lt; ZIP_STR_MASK) (encoding) &amp;= ZIP_STR_MASK; \\</span></span><br><span class=\"line\"><span class=\"meta\">&#125; while(0)</span></span><br></pre></td></tr></table></figure>\n\n<p>ZIP_ENTRY_ENCODING()提取出ptr出的encoding，ZIP_STR_MASK的值是0xc0，对于所有的整数编码均是以11开头，而字符串编码的开头一字节均小于11000000(0xc0)。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do &#123;                          \\</span></span><br><span class=\"line\"><span class=\"meta\">    <span class=\"keyword\">if</span> ((ptr)[0] &lt; ZIP_BIGLEN) &#123;                                               \\</span></span><br><span class=\"line\"><span class=\"meta\">        (prevlensize) = 1;                                                     \\</span></span><br><span class=\"line\"><span class=\"meta\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                   \\</span></span><br><span class=\"line\"><span class=\"meta\">        (prevlensize) = 5;                                                     \\</span></span><br><span class=\"line\"><span class=\"meta\">    &#125;                                                                          \\</span></span><br><span class=\"line\"><span class=\"meta\">&#125; while(0);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do &#123;                     \\</span></span><br><span class=\"line\"><span class=\"meta\">    ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);                                  \\</span></span><br><span class=\"line\"><span class=\"meta\">    <span class=\"keyword\">if</span> ((prevlensize) == 1) &#123;                                                  \\</span></span><br><span class=\"line\"><span class=\"meta\">        (prevlen) = (ptr)[0];                                                  \\</span></span><br><span class=\"line\"><span class=\"meta\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((prevlensize) == 5) &#123;                                           \\</span></span><br><span class=\"line\"><span class=\"meta\">        assert(sizeof((prevlensize)) == 4);                                    \\</span></span><br><span class=\"line\"><span class=\"meta\">        memcpy(&amp;(prevlen), ((char*)(ptr)) + 1, 4);                             \\</span></span><br><span class=\"line\"><span class=\"meta\">        memrev32ifbe(&amp;prevlen);                                                \\</span></span><br><span class=\"line\"><span class=\"meta\">    &#125;                                                                          \\</span></span><br><span class=\"line\"><span class=\"meta\">&#125; while(0);</span></span><br></pre></td></tr></table></figure>\n\n<p>ZIP_DECODE_PREVLEN()在ptr处提取出prelen和prelen的大小。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do &#123;                    \\</span></span><br><span class=\"line\"><span class=\"meta\">    ZIP_ENTRY_ENCODING((ptr), (encoding));                                     \\</span></span><br><span class=\"line\"><span class=\"meta\">    <span class=\"keyword\">if</span> ((encoding) &lt; ZIP_STR_MASK) &#123;                                           \\</span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"keyword\">if</span> ((encoding) == ZIP_STR_06B) &#123;                                       \\</span></span><br><span class=\"line\"><span class=\"meta\">            (lensize) = 1;                                                     \\</span></span><br><span class=\"line\"><span class=\"meta\">            (len) = (ptr)[0] &amp; 0x3f;                                           \\</span></span><br><span class=\"line\"><span class=\"meta\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((encoding) == ZIP_STR_14B) &#123;                                \\</span></span><br><span class=\"line\"><span class=\"meta\">            (lensize) = 2;                                                     \\</span></span><br><span class=\"line\"><span class=\"meta\">            (len) = (((ptr)[0] &amp; 0x3f) &lt;&lt; 8) | (ptr)[1];                       \\</span></span><br><span class=\"line\"><span class=\"meta\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (encoding == ZIP_STR_32B) &#123;                                  \\</span></span><br><span class=\"line\"><span class=\"meta\">            (lensize) = 5;                                                     \\</span></span><br><span class=\"line\"><span class=\"meta\">            (len) = ((ptr)[1] &lt;&lt; 24) |                                         \\</span></span><br><span class=\"line\"><span class=\"meta\">                    ((ptr)[2] &lt;&lt; 16) |                                         \\</span></span><br><span class=\"line\"><span class=\"meta\">                    ((ptr)[3] &lt;&lt;  8) |                                         \\</span></span><br><span class=\"line\"><span class=\"meta\">                    ((ptr)[4]);                                                \\</span></span><br><span class=\"line\"><span class=\"meta\">        &#125; <span class=\"keyword\">else</span> &#123;                                                               \\</span></span><br><span class=\"line\"><span class=\"meta\">            assert(NULL);                                                      \\</span></span><br><span class=\"line\"><span class=\"meta\">        &#125;                                                                      \\</span></span><br><span class=\"line\"><span class=\"meta\">    &#125; <span class=\"keyword\">else</span> &#123;                                                                   \\</span></span><br><span class=\"line\"><span class=\"meta\">        (lensize) = 1;                                                         \\</span></span><br><span class=\"line\"><span class=\"meta\">        (len) = zipIntSize(encoding);                                          \\</span></span><br><span class=\"line\"><span class=\"meta\">    &#125;                                                                          \\</span></span><br><span class=\"line\"><span class=\"meta\">&#125; while(0);</span></span><br></pre></td></tr></table></figure>\n\n<p>ZIP_DECODE_LENGTH宏将对应ptr的encoding编码，entrylen，和entrylen的大小都提取出来。</p>\n<h3 id=\"3，创建ziplist\"><a href=\"#3，创建ziplist\" class=\"headerlink\" title=\"3，创建ziplist\"></a>3，创建ziplist</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">***</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistNew</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> bytes = ZIPLIST_HEADER_SIZE+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl = zmalloc(bytes);</span><br><span class=\"line\">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</span><br><span class=\"line\">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class=\"line\">    ZIPLIST_LENGTH(zl) = <span class=\"number\">0</span>;</span><br><span class=\"line\">    zl[bytes<span class=\"number\">-1</span>] = ZIP_END;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> zl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过调用zmalloc()分配内存，最初分配的内存大小刚好为zlbytes，zltail，zllen以及zlend四个部分相加。分配了内存后要对header的各个部分进行初始化，zlbytes设置为实际长度bytes，由于此时ziplist为空，所以ztail指针指向ziplist的header的结尾；zllen设为0。注意到ziplist内部存储采用的是小端对齐，所以若设置为大端对齐则需要经过intrev32ifbe()转换。</p>\n<h3 id=\"4，删除ziplist\"><a href=\"#4，删除ziplist\" class=\"headerlink\" title=\"4，删除ziplist\"></a>4，删除ziplist</h3><p>ziplist删除有两种方式，一种是对指定的entry进行删除；另一种是通过entry的下标引用进行范围删除。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistDelete</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> **p)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> offset = *p-zl;</span><br><span class=\"line\">    zl = __ziplistDelete(zl,*p,<span class=\"number\">1</span>);</span><br><span class=\"line\">    *p = zl+offset;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> zl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistDeleteRange</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> index, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> num)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p = ziplistIndex(zl,index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (p == <span class=\"literal\">NULL</span>) ? zl : __ziplistDelete(zl,p,num);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于单个entry删除，其中p是一个二维指针，指针的解引用是一个指向一个entry的指针，该函数实现对于指定压缩表zl删除p指向的entry。首先计算出此时待删除的entry的偏移量，内部又是通过__ziplistDelete()这个内部API实现删除，因为ziplist内部删除时会重新分配内存，所以zl的地址可能会改变，需要重新计算此时新的*p。</p>\n<p>对于范围删除，首先通过虚拟的下标index算出对于此时待删除的第一个entry，再调用__ziplistDelete()进行删除。值得注意的是对于范围删除没有存储新的entry指针因为 p是通过下标算出来的，它并不是传入的一个参数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *__ziplistDelete(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> num) &#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> i, totlen, deleted = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> offset;</span><br><span class=\"line\">    <span class=\"type\">int</span> nextdiff = <span class=\"number\">0</span>;</span><br><span class=\"line\">    zlentry first, tail;</span><br><span class=\"line\">    first = zipEntry(p);</span><br><span class=\"line\">    <span class=\"comment\">//找到要删除的最后一个entry，记录实际要删除的entry数量</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; p[<span class=\"number\">0</span>] != ZIP_END &amp;&amp; i &lt; num; i++) &#123;</span><br><span class=\"line\">        p += zipRawEntryLength(p);</span><br><span class=\"line\">        deleted++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    totlen = p-first.p;<span class=\"comment\">//代表要删除的总的entry的字节数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (totlen &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//关键部分，删除后，更新要p对应的entry的prelen，使其要与first对应的prelen一致</span></span><br><span class=\"line\">            nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);</span><br><span class=\"line\">            p -= nextdiff;</span><br><span class=\"line\">            zipPrevEncodeLength(p,first.prevrawlen);</span><br><span class=\"line\">            <span class=\"comment\">//更新zltail，此时长度应减去totlen</span></span><br><span class=\"line\">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class=\"line\">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen);</span><br><span class=\"line\">            <span class=\"comment\">//若p不是最后一个entry，则要对tail的特殊处理</span></span><br><span class=\"line\">            tail = zipEntry(p);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p[tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class=\"line\">                ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class=\"line\">                   intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//将p后面的entry直接“拼接”到frist后面</span></span><br><span class=\"line\">            memmove(first.p,p,</span><br><span class=\"line\">                intrev32ifbe(ZIPLIST_BYTES(zl))-(p-zl)<span class=\"number\">-1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;    </span><br><span class=\"line\">            <span class=\"comment\">//直接删去，不需要拼接，只需要修改zltail</span></span><br><span class=\"line\">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class=\"line\">                intrev32ifbe((first.p-zl)-first.prevrawlen);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//修改zllen，重新结尾填充0xFF</span></span><br><span class=\"line\">        offset = first.p-zl;</span><br><span class=\"line\">        zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl))-totlen+nextdiff);</span><br><span class=\"line\">        ZIPLIST_INCR_LENGTH(zl,-deleted);</span><br><span class=\"line\">        p = zl+offset;</span><br><span class=\"line\">        <span class=\"comment\">//连锁更新</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextdiff != <span class=\"number\">0</span>)</span><br><span class=\"line\">            zl = __ziplistCascadeUpdate(zl,p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> zl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/ziplist.bmp\"></p>\n<p>__ziplistDelete()实现对ziplist从指定p指向的entry处删除num个entry的操作。</p>\n<p>删除的关键在于头尾的处理，如图所示，由于p所指的entry和first的prelen的编码长度可能不一致，所以需要将p进行偏移，偏移量正好是两个prelen编码长度之差。同时如图所示，由于我们要将中间部分去掉，首先zltail应减去待删除的长度。若此时p刚好是整个ziplist的最后一个entry，将它拼接到first后面，zltail的值应当始终为first；若p指向的entry后面还有其他的entry，那么此时最后一个entry的偏移量应当在zltail减去了totlen基础上加上nextdiff。然后是对zllen的更新，zl的重新分配内存，同时要对ziplist的最后一个字节填充0xFF。最后当存在nextdiff时，要进行连锁式更新。对于连锁式更新，我们在接下来章节会进行介绍。</p>\n<h3 id=\"5，插入entry\"><a href=\"#5，插入entry\" class=\"headerlink\" title=\"5，插入entry\"></a>5，插入entry</h3><p>将entry插入到zl中p指向的entry处，ziplistInsert()内部是通过调用__ziplistInsert()。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistInsert</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *s, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> slen)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *__ziplistInsert(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *s, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> slen) &#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> prevlensize, prevlen = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> offset;</span><br><span class=\"line\">    <span class=\"type\">int</span> nextdiff = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> encoding = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> value = <span class=\"number\">123456789</span>; </span><br><span class=\"line\">    zlentry tail;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ptail[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">            prevlen = zipRawEntryLength(ptail);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class=\"line\">        reqlen = zipIntSize(encoding);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        reqlen = slen;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reqlen += zipPrevEncodeLength(<span class=\"literal\">NULL</span>,prevlen);</span><br><span class=\"line\">    reqlen += zipEncodeLength(<span class=\"literal\">NULL</span>,encoding,slen);</span><br><span class=\"line\">    nextdiff = (p[<span class=\"number\">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class=\"number\">0</span>;</span><br><span class=\"line\">    offset = p-zl;</span><br><span class=\"line\">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class=\"line\">    p = zl+offset;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class=\"number\">-1</span>+nextdiff);</span><br><span class=\"line\">        zipPrevEncodeLength(p+reqlen,reqlen);</span><br><span class=\"line\"></span><br><span class=\"line\">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class=\"line\">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class=\"line\">        tail = zipEntry(p+reqlen);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class=\"line\">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class=\"line\">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextdiff != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        offset = p-zl;</span><br><span class=\"line\">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class=\"line\">        p = zl+offset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p += zipPrevEncodeLength(p,prevlen);</span><br><span class=\"line\">    p += zipEncodeLength(p,encoding,slen);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(p,s,slen);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        zipSaveInteger(p,value,encoding);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ZIPLIST_INCR_LENGTH(zl,<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> zl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>插入与删除类似，步骤如下：</p>\n<p>(1)，首先是要确定插入位置的前一个entry的长度，若插入的是最后一个entry，直接用ziplist的zltail找到最后一个entry并找到这个entry的长度；若插入的不是最后一个entry，ZIP_DECODE_PREVLEN()宏直接用这个entry的prelen参数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (p[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">       ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (ptail[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">           prevlen = zipRawEntryLength(ptail);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/step1.bmp\"></p>\n<p>(2)，接着是对该entry本身编码，若该entry可编码成整型数，则按照entry介绍的几种整数编码；若不能则按照字符串进行编码。然后计算entry长度的编码的长度和prelen的编码的长度，这样将三者相加，即可得到实际插入进ziplist中entry的大小reqlen。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class=\"line\">        reqlen = zipIntSize(encoding);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        reqlen = slen;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">reqlen += zipPrevEncodeLength(<span class=\"literal\">NULL</span>,prevlen);</span><br><span class=\"line\">reqlen += zipEncodeLength(<span class=\"literal\">NULL</span>,encoding,slen);</span><br></pre></td></tr></table></figure>\n\n<p>(3)，如果要插入的位置后面还有entry，需要计算nextdiff以使得后面的entry在记录待插入的entry的时候有足够的空间。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"> nextdiff = (p[<span class=\"number\">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">***</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">zipPrevLenByteDiff</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> len)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> prevlensize;</span><br><span class=\"line\">    ZIP_DECODE_PREVLENSIZE(p, prevlensize);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> zipPrevEncodeLength(<span class=\"literal\">NULL</span>, len) - prevlensize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(4)，对ziplist调用zrealloc()重新分配内存，新的内存大小在原来的基础上加上reqlen和nextdiff，此时zl的值可能会发生改变，所以要记录下插入位置的偏移量。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">offset = p-zl;</span><br><span class=\"line\">zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class=\"line\">p = zl+offset;</span><br></pre></td></tr></table></figure>\n\n<p>(5)，将插入位置后面的entry（如果存在）拷贝到新的内存空间上正确的位置，更新下个entry的prelen，并更新ziplist的zltail。如图所示，要将原先p-nextdiff位置对应到下面红色方框处，拷贝长度即时从p-nextdiff到实线框结尾。</p>\n<p><img src=\"/images/step4.bmp\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (p[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">    memmove(p+reqlen,p-nextdiff,curlen-offset<span class=\"number\">-1</span>+nextdiff);</span><br><span class=\"line\">    zipPrevEncodeLength(p+reqlen,reqlen);</span><br><span class=\"line\"></span><br><span class=\"line\">    ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class=\"line\">        intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class=\"line\">    tail = zipEntry(p+reqlen);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class=\"line\">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class=\"line\">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(6) ，若nextdiff不为0，则需要进行连锁式更新</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (nextdiff != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">       offset = p-zl;</span><br><span class=\"line\">       zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class=\"line\">       p = zl+offset;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>(7)，处理完后面的entry后，最后是将待插入的entry真正地写入。在p处首先写入header，分别是prelen和rawlen，然后写入编码后的字符串或整数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">p += zipPrevEncodeLength(p,prevlen);</span><br><span class=\"line\">p += zipEncodeLength(p,encoding,slen);</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class=\"line\">     <span class=\"built_in\">memcpy</span>(p,s,slen);</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     zipSaveInteger(p,value,encoding);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> ZIPLIST_INCR_LENGTH(zl,<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6，连锁式更新\"><a href=\"#6，连锁式更新\" class=\"headerlink\" title=\"6，连锁式更新\"></a>6，连锁式更新</h3><p>在前面的分析中，存在一种称为连锁式更新的现象：当插入新的entry时，当前entry现有的prelen字段无法表示上个entry的大小，需要对prelen进行重新的编码，这样的操作可能会造成当前entry自身的大小发生变化，我们便需要计算下个entry的prelen，重新编码…整个迭代过程直到entry的大小不再发生变化停止，也就是nextdiff为0。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *__ziplistCascadeUpdate(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p) &#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> offset, noffset, extra;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *np;</span><br><span class=\"line\">    zlentry cur, next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">        cur = zipEntry(p);</span><br><span class=\"line\">        rawlen = cur.headersize + cur.len;</span><br><span class=\"line\">        rawlensize = zipPrevEncodeLength(<span class=\"literal\">NULL</span>,rawlen);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p[rawlen] == ZIP_END) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        next = zipEntry(p+rawlen);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next.prevrawlen == rawlen) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next.prevrawlensize &lt; rawlensize) &#123;</span><br><span class=\"line\">            offset = p-zl;</span><br><span class=\"line\">            extra = rawlensize-next.prevrawlensize;</span><br><span class=\"line\">            zl = ziplistResize(zl,curlen+extra);</span><br><span class=\"line\">            p = zl+offset;</span><br><span class=\"line\">            np = p+rawlen;</span><br><span class=\"line\">            noffset = np-zl;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> ((zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) &#123;</span><br><span class=\"line\">                ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class=\"line\">                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          memmove(np+rawlensize,</span><br><span class=\"line\">                np+next.prevrawlensize,</span><br><span class=\"line\">                curlen-noffset-next.prevrawlensize<span class=\"number\">-1</span>);</span><br><span class=\"line\">            zipPrevEncodeLength(np,rawlen);</span><br><span class=\"line\">            p += rawlen;</span><br><span class=\"line\">            curlen += extra;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next.prevrawlensize &gt; rawlensize) &#123;</span><br><span class=\"line\">              zipPrevEncodeLengthForceLarge(p+rawlen,rawlen);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                zipPrevEncodeLength(p+rawlen,rawlen);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> zl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>(1)，计算当前entry和下个entry,并判断是否达到终止条件：已经是最后一个entry；下个entry的prelen刚好等于当前entry的长度。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">cur = zipEntry(p);</span><br><span class=\"line\">   rawlen = cur.headersize + cur.len;</span><br><span class=\"line\">   rawlensize = zipPrevEncodeLength(<span class=\"literal\">NULL</span>,rawlen);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (p[rawlen] == ZIP_END) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">   next = zipEntry(p+rawlen);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (next.prevrawlen == rawlen) <span class=\"keyword\">break</span>;</span><br></pre></td></tr></table></figure>\n\n<p>(2)，下面讨论三种情况：情况1，下个entry的prelen字段的大小不足够表示当前entry长度，需要扩充prelen字段大小 。处理方式和插入部分处理类似，首先计算出next entry增加的长度，并对ziplist进行扩容；若next entry不是最后一个entry，则要修改ziplist的zltail字段；接着开始将next entry拷贝到正确的位置，对next entry的prelen重新编码以正确反映当前entry的长度。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (next.prevrawlensize &lt; rawlensize) &#123;//情况1</span><br><span class=\"line\">            offset = p-zl;</span><br><span class=\"line\">            extra = rawlensize-next.prevrawlensize;</span><br><span class=\"line\">            zl = ziplistResize(zl,curlen+extra);</span><br><span class=\"line\">            p = zl+offset;</span><br><span class=\"line\">            np = p+rawlen;</span><br><span class=\"line\">            noffset = np-zl;</span><br><span class=\"line\">           if ((zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) &#123;</span><br><span class=\"line\">                ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class=\"line\">                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          memmove(np+rawlensize,</span><br><span class=\"line\">                np+next.prevrawlensize,</span><br><span class=\"line\">                curlen-noffset-next.prevrawlensize-1);</span><br><span class=\"line\">            zipPrevEncodeLength(np,rawlen);</span><br><span class=\"line\">            p += rawlen;</span><br><span class=\"line\">            curlen += extra;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<p>2，下个entry的prelen字段大小足够表示当前entry长度且还有空余，需要压缩prelen字段大小。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (next.prevrawlensize &gt; rawlensize) &#123;</span><br><span class=\"line\">              zipPrevEncodeLengthForceLarge(p+rawlen,rawlen);</span><br><span class=\"line\">  &#125; </span><br></pre></td></tr></table></figure>\n\n<p> 3，下个entry的prelen字段的大小刚好足够表示当前entry长度，此时只需要对next entry的prelen字段重新编码，无需扩充和压缩空间。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                zipPrevEncodeLength(p+rawlen,rawlen);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7，下标搜索\"><a href=\"#7，下标搜索\" class=\"headerlink\" title=\"7，下标搜索\"></a>7，下标搜索</h3><p>  对ziplist指定的第index个entry(从零开始),返回对应的entry指针；若index为正，则是从头开始往尾，若index为－，则是从最后一个entry往前计算，若ziplist不包含entry，则返回NULL。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistIndex</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> prevlensize, prevlen = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//负数，从尾向头</span></span><br><span class=\"line\">        index = (-index)<span class=\"number\">-1</span>;</span><br><span class=\"line\">        p = ZIPLIST_ENTRY_TAIL(zl);<span class=\"comment\">//最后一个entry</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">            ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);<span class=\"comment\">//计算出前一个entry的长度</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (prevlen &gt; <span class=\"number\">0</span> &amp;&amp; index--) &#123;<span class=\"comment\">//迭代直到找到对应下标的entry或已经是头</span></span><br><span class=\"line\">                p -= prevlen;</span><br><span class=\"line\">                ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//正数，从头到尾</span></span><br><span class=\"line\">        p = ZIPLIST_ENTRY_HEAD(zl);<span class=\"comment\">//第一个entry</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p[<span class=\"number\">0</span>] != ZIP_END &amp;&amp; index--) &#123;<span class=\"comment\">//迭代直到找到对应下标的entry或已经是尾</span></span><br><span class=\"line\">            p += zipRawEntryLength(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (p[<span class=\"number\">0</span>] == ZIP_END || index &gt; <span class=\"number\">0</span>) ? <span class=\"literal\">NULL</span> : p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<p><strong>参考:</strong>  <a href=\"https://github.com/redis/redis/blob/unstable/src/ziplist.c\">https://github.com/redis/redis/blob/unstable/src/ziplist.c</a></p>\n"}]