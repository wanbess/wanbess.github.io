<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="一，概述ziplist是一种特殊的数据结构，它将链式的数据排列成内存中连续空间，并通过相应的编码形式实现了高效的内存压缩。在原理上，ziplist像是链表和线性数组的一种综合。 ziplist能存储字符串和整数，对于整数的编码，ziplist采用将其编码成实际的数字而不是字符系列。它允许实现stack类似的push 和 pop操作。时间复杂度为O(1)，但实际中由于需要对内存的再分配，所以近似时间">
<meta property="og:type" content="article">
<meta property="og:title" content="redis之ziplist">
<meta property="og:url" content="http://example.com/posts/42240f40.html">
<meta property="og:site_name" content="wanbess的杂物间">
<meta property="og:description" content="一，概述ziplist是一种特殊的数据结构，它将链式的数据排列成内存中连续空间，并通过相应的编码形式实现了高效的内存压缩。在原理上，ziplist像是链表和线性数组的一种综合。 ziplist能存储字符串和整数，对于整数的编码，ziplist采用将其编码成实际的数字而不是字符系列。它允许实现stack类似的push 和 pop操作。时间复杂度为O(1)，但实际中由于需要对内存的再分配，所以近似时间">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/ziplist.bmp">
<meta property="og:image" content="http://example.com/images/step1.bmp">
<meta property="og:image" content="http://example.com/images/step4.bmp">
<meta property="article:published_time" content="2022-06-05T07:02:33.177Z">
<meta property="article:modified_time" content="2022-06-10T06:48:11.344Z">
<meta property="article:author" content="wanbess">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/ziplist.bmp">

<link rel="canonical" href="http://example.com/posts/42240f40.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>redis之ziplist | wanbess的杂物间</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">wanbess的杂物间</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-trash">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>垃圾箱</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="sitemap fa-fw"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/42240f40.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wanbess">
      <meta itemprop="description" content="Do not go gentle into that good night">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wanbess的杂物间">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          redis之ziplist
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-05 15:02:33" itemprop="dateCreated datePublished" datetime="2022-06-05T15:02:33+08:00">2022-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-10 14:48:11" itemprop="dateModified" datetime="2022-06-10T14:48:11+08:00">2022-06-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一，概述"><a href="#一，概述" class="headerlink" title="一，概述"></a>一，概述</h2><p>ziplist是一种特殊的数据结构，它将链式的数据排列成内存中连续空间，并通过相应的编码形式实现了高效的内存压缩。在原理上，ziplist像是链表和线性数组的一种综合。</p>
<p>ziplist能存储字符串和整数，对于整数的编码，ziplist采用将其编码成实际的数字而不是字符系列。它允许实现stack类似的push 和 pop操作。时间复杂度为O(1)，但实际中由于需要对内存的再分配，所以近似时间复杂度为O(N)。</p>
<h2 id="二，基本结构"><a href="#二，基本结构" class="headerlink" title="二，基本结构"></a>二，基本结构</h2><p>ziplist的内部结构从头到尾包含以下几个部分： zlbytes  zltail zllen entry zlend   </p>
<h3 id="zlbytes"><a href="#zlbytes" class="headerlink" title="zlbytes"></a>zlbytes</h3><p>是一个无符号整型，代表整个ziplist结构所占内存的大小。能再O(1)时间内取得并修改ziplist的大小。</p>
<h3 id="zltail"><a href="#zltail" class="headerlink" title="zltail"></a>zltail</h3><p>zltail是最后一个entry相对于ziplist起始位置的偏移量。存储这个参数是为了在O(1)时间复杂度内找到最后一个ziplist存储的元素，并进行push和pop操作。</p>
<h3 id="zllen"><a href="#zllen" class="headerlink" title="zllen"></a>zllen</h3><p>zllen记录了整个ziplist记录的条目(entry)的数量，值得注意的是当这个值比(1&lt;&lt;16)-2大时，需要完整遍历一遍ziplist才能得到真实的长度，zllen只有2个字节长度。</p>
<h3 id="zlend"><a href="#zlend" class="headerlink" title="zlend"></a>zlend</h3><p>一个特殊的标记，用来表明ziplist的结尾，值为255(0xFF)。</p>
<h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p>entry是ziplist中存储数据的实体，每个entry的开头都包含两部分信息：前一个entry长度的编码和当前entry的编码信息，并且均有各自的编码方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize, prevrawlen;<span class="comment">//上个entry长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lensize, len;<span class="comment">//当前entry长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headersize;<span class="comment">//entry的header长度，用p+headersize可得到存储数据的起始地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encoding;<span class="comment">//编码方式</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;<span class="comment">//当前entry的起始地址</span></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure>

<p>对于上一个entry的长度，有两种情况：若长度小于254字节，则该长度用8bit无符号整数表示，则只需要一个字节；若长度大于等于254字节，则该长度用5个字节表示，其中第一个字节置为254表示这个整数编码，其余4个字节用来记录实际长度。</p>
<p>对于当前entry的长度编码，则根据当前存储的内容而不同。如果存储的是整数，则前两位置为“11”，其余位代表实际长度；如果存储的是字符串，前两位表示位相应的编码方式，其他位代表实际的长度。</p>
<table>
<thead>
<tr>
<th align="center">编码方式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">00XXXXXX</td>
<td align="center">字符串长度小于等于63</td>
</tr>
<tr>
<td align="center">01XXXXXX | XXXXXXXX</td>
<td align="center">字符串长小于等于16383</td>
</tr>
<tr>
<td align="center">10_ _ _ _ _ _ |XXXXXXXX| RRRRRRRR|KKKKKKKKK</td>
<td align="center">字符串长度大于16383</td>
</tr>
<tr>
<td align="center">11000000</td>
<td align="center">int16整数</td>
</tr>
<tr>
<td align="center">11010000</td>
<td align="center">int32整数</td>
</tr>
<tr>
<td align="center">11100000</td>
<td align="center">int64整数</td>
</tr>
<tr>
<td align="center">11110000</td>
<td align="center">24bit有符号整数</td>
</tr>
<tr>
<td align="center">11111110</td>
<td align="center">8bit有符号整数</td>
</tr>
<tr>
<td align="center">1111XXXX(XXXX介于0000和1101之间)</td>
<td align="center">无符号的0-12整数，0对应0001，1101对应12</td>
</tr>
</tbody></table>
<p>​                                                                          表一：ziplist中entry编码方式</p>
<p> 例子： 若此时encoding部分为 00000100 ，表示这是个字符串，且长度为4。</p>
<h2 id="三，源码分析"><a href="#三，源码分析" class="headerlink" title="三，源码分析"></a>三，源码分析</h2><p>ziplist.h提供了一些基本接口供外部调用，下面列出一些常用的函数接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistNew</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistPush</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">char</span> *s, <span class="type">unsigned</span> <span class="type">int</span> slen, <span class="type">int</span> where)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistIndex</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">int</span> index)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistNext</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">char</span> *p)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistPrev</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">char</span> *p)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ziplistGet</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">char</span> **sval, <span class="type">unsigned</span> <span class="type">int</span> *slen, <span class="type">long</span> <span class="type">long</span> *lval)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistInsert</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">char</span> *s, <span class="type">unsigned</span> <span class="type">int</span> slen)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistDelete</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">char</span> **p)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistDeleteRange</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">int</span> index, <span class="type">unsigned</span> <span class="type">int</span> num)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ziplistCompare</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">char</span> *s, <span class="type">unsigned</span> <span class="type">int</span> slen)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistFind</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">char</span> *vstr, <span class="type">unsigned</span> <span class="type">int</span> vlen, <span class="type">unsigned</span> <span class="type">int</span> skip)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ziplistLen</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl)</span>;</span><br></pre></td></tr></table></figure>

<p>除了这些常用API，还有一些内部用于编码和解码的函数和宏。</p>
<h3 id="1，编码相关"><a href="#1，编码相关" class="headerlink" title="1，编码相关"></a>1，编码相关</h3><p>   ziplist内部操作涉及了很多数据的解压和编码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">zipPrevEncodeLength</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (len &lt; ZIP_BIGLEN) ? <span class="number">1</span> : <span class="keyword">sizeof</span>(len)+<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; ZIP_BIGLEN) &#123;</span><br><span class="line">            p[<span class="number">0</span>] = len;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[<span class="number">0</span>] = ZIP_BIGLEN;</span><br><span class="line">            <span class="built_in">memcpy</span>(p+<span class="number">1</span>,&amp;len,<span class="keyword">sizeof</span>(len));</span><br><span class="line">            memrev32ifbe(p+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="keyword">sizeof</span>(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>zipPrevEncodeLength()对prelen长度进行编码，存储到p的header中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">zipEncodeLength</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">char</span> encoding, <span class="type">unsigned</span> <span class="type">int</span> rawlen)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> len = <span class="number">1</span>, buf[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rawlen &lt;= <span class="number">0x3f</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">            buf[<span class="number">0</span>] = ZIP_STR_06B | rawlen;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rawlen &lt;= <span class="number">0x3fff</span>) &#123;</span><br><span class="line">            len += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">            buf[<span class="number">0</span>] = ZIP_STR_14B | ((rawlen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x3f</span>);</span><br><span class="line">            buf[<span class="number">1</span>] = rawlen &amp; <span class="number">0xff</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len += <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">            buf[<span class="number">0</span>] = ZIP_STR_32B;</span><br><span class="line">            buf[<span class="number">1</span>] = (rawlen &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            buf[<span class="number">2</span>] = (rawlen &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            buf[<span class="number">3</span>] = (rawlen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            buf[<span class="number">4</span>] = rawlen &amp; <span class="number">0xff</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">        buf[<span class="number">0</span>] = encoding;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(p,buf,len);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>zipEncodeLength()函数对当前entry进行编码，若是字符串编码，根据rawlen可以分为三类：长度小于等于63，小于等于16383，长度大于16383，具体编码方式参考表一；若是整数编码则不做处理，因为所有的整数编码只占一个字节，并且encoding已经在之前zipTryEncoding()中设置了。代码的实现中是通过一个先将rawlen编码写到buf的中间数组，再将buf复制到p。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">zipTryEncoding</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *entry, <span class="type">unsigned</span> <span class="type">int</span> entrylen, <span class="type">long</span> <span class="type">long</span> *v, <span class="type">unsigned</span> <span class="type">char</span> *encoding)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entrylen &gt;= <span class="number">32</span> || entrylen == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (string2ll((<span class="type">char</span>*)entry,entrylen,&amp;value)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt;= <span class="number">12</span>) &#123;</span><br><span class="line">            *encoding = ZIP_INT_IMM_MIN+value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT8_MIN &amp;&amp; value &lt;= INT8_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_8B;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT16_MIN &amp;&amp; value &lt;= INT16_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_16B;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT24_MIN &amp;&amp; value &lt;= INT24_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_24B;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT32_MIN &amp;&amp; value &lt;= INT32_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_32B;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *encoding = ZIP_INT_64B;</span><br><span class="line">        &#125;</span><br><span class="line">        *v = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>zipTryEncoding()实现对指定entry的整数编码的尝试，只有能转换成32为</p>
<p>对于编码entry的流程，首先是通过zipTryEncoding()判断能否进行整数编码，然后是通过zipPrevEncodeLength()对prelen进行编码，最后通过zipEncodeLength()对当前entry进行编码。</p>
<h3 id="2，解码相关"><a href="#2，解码相关" class="headerlink" title="2，解码相关"></a>2，解码相关</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_ENTRY_ENCODING(ptr, encoding) do &#123;  \</span></span><br><span class="line"><span class="meta">    (encoding) = (ptr[0]); \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((encoding) &lt; ZIP_STR_MASK) (encoding) &amp;= ZIP_STR_MASK; \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br></pre></td></tr></table></figure>

<p>ZIP_ENTRY_ENCODING()提取出ptr出的encoding，ZIP_STR_MASK的值是0xc0，对于所有的整数编码均是以11开头，而字符串编码的开头一字节均小于11000000(0xc0)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do &#123;                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((ptr)[0] &lt; ZIP_BIGLEN) &#123;                                               \</span></span><br><span class="line"><span class="meta">        (prevlensize) = 1;                                                     \</span></span><br><span class="line"><span class="meta">    &#125; <span class="keyword">else</span> &#123;                                                                   \</span></span><br><span class="line"><span class="meta">        (prevlensize) = 5;                                                     \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">&#125; while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do &#123;                     \</span></span><br><span class="line"><span class="meta">    ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);                                  \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((prevlensize) == 1) &#123;                                                  \</span></span><br><span class="line"><span class="meta">        (prevlen) = (ptr)[0];                                                  \</span></span><br><span class="line"><span class="meta">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((prevlensize) == 5) &#123;                                           \</span></span><br><span class="line"><span class="meta">        assert(sizeof((prevlensize)) == 4);                                    \</span></span><br><span class="line"><span class="meta">        memcpy(&amp;(prevlen), ((char*)(ptr)) + 1, 4);                             \</span></span><br><span class="line"><span class="meta">        memrev32ifbe(&amp;prevlen);                                                \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">&#125; while(0);</span></span><br></pre></td></tr></table></figure>

<p>ZIP_DECODE_PREVLEN()在ptr处提取出prelen和prelen的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do &#123;                    \</span></span><br><span class="line"><span class="meta">    ZIP_ENTRY_ENCODING((ptr), (encoding));                                     \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((encoding) &lt; ZIP_STR_MASK) &#123;                                           \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> ((encoding) == ZIP_STR_06B) &#123;                                       \</span></span><br><span class="line"><span class="meta">            (lensize) = 1;                                                     \</span></span><br><span class="line"><span class="meta">            (len) = (ptr)[0] &amp; 0x3f;                                           \</span></span><br><span class="line"><span class="meta">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((encoding) == ZIP_STR_14B) &#123;                                \</span></span><br><span class="line"><span class="meta">            (lensize) = 2;                                                     \</span></span><br><span class="line"><span class="meta">            (len) = (((ptr)[0] &amp; 0x3f) &lt;&lt; 8) | (ptr)[1];                       \</span></span><br><span class="line"><span class="meta">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_STR_32B) &#123;                                  \</span></span><br><span class="line"><span class="meta">            (lensize) = 5;                                                     \</span></span><br><span class="line"><span class="meta">            (len) = ((ptr)[1] &lt;&lt; 24) |                                         \</span></span><br><span class="line"><span class="meta">                    ((ptr)[2] &lt;&lt; 16) |                                         \</span></span><br><span class="line"><span class="meta">                    ((ptr)[3] &lt;&lt;  8) |                                         \</span></span><br><span class="line"><span class="meta">                    ((ptr)[4]);                                                \</span></span><br><span class="line"><span class="meta">        &#125; <span class="keyword">else</span> &#123;                                                               \</span></span><br><span class="line"><span class="meta">            assert(NULL);                                                      \</span></span><br><span class="line"><span class="meta">        &#125;                                                                      \</span></span><br><span class="line"><span class="meta">    &#125; <span class="keyword">else</span> &#123;                                                                   \</span></span><br><span class="line"><span class="meta">        (lensize) = 1;                                                         \</span></span><br><span class="line"><span class="meta">        (len) = zipIntSize(encoding);                                          \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">&#125; while(0);</span></span><br></pre></td></tr></table></figure>

<p>ZIP_DECODE_LENGTH宏将对应ptr的encoding编码，entrylen，和entrylen的大小都提取出来。</p>
<h3 id="3，创建ziplist"><a href="#3，创建ziplist" class="headerlink" title="3，创建ziplist"></a>3，创建ziplist</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">***</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistNew</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bytes = ZIPLIST_HEADER_SIZE+<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl = zmalloc(bytes);</span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用zmalloc()分配内存，最初分配的内存大小刚好为zlbytes，zltail，zllen以及zlend四个部分相加。分配了内存后要对header的各个部分进行初始化，zlbytes设置为实际长度bytes，由于此时ziplist为空，所以ztail指针指向ziplist的header的结尾；zllen设为0。注意到ziplist内部存储采用的是小端对齐，所以若设置为大端对齐则需要经过intrev32ifbe()转换。</p>
<h3 id="4，删除ziplist"><a href="#4，删除ziplist" class="headerlink" title="4，删除ziplist"></a>4，删除ziplist</h3><p>ziplist删除有两种方式，一种是对指定的entry进行删除；另一种是通过entry的下标引用进行范围删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistDelete</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">char</span> **p)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> offset = *p-zl;</span><br><span class="line">    zl = __ziplistDelete(zl,*p,<span class="number">1</span>);</span><br><span class="line">    *p = zl+offset;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistDeleteRange</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">int</span> index, <span class="type">unsigned</span> <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = ziplistIndex(zl,index);</span><br><span class="line">    <span class="keyword">return</span> (p == <span class="literal">NULL</span>) ? zl : __ziplistDelete(zl,p,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于单个entry删除，其中p是一个二维指针，指针的解引用是一个指向一个entry的指针，该函数实现对于指定压缩表zl删除p指向的entry。首先计算出此时待删除的entry的偏移量，内部又是通过__ziplistDelete()这个内部API实现删除，因为ziplist内部删除时会重新分配内存，所以zl的地址可能会改变，需要重新计算此时新的*p。</p>
<p>对于范围删除，首先通过虚拟的下标index算出对于此时待删除的第一个entry，再调用__ziplistDelete()进行删除。值得注意的是对于范围删除没有存储新的entry指针因为 p是通过下标算出来的，它并不是传入的一个参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> *__ziplistDelete(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">int</span> num) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, totlen, deleted = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line">    <span class="type">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    zlentry first, tail;</span><br><span class="line">    first = zipEntry(p);</span><br><span class="line">    <span class="comment">//找到要删除的最后一个entry，记录实际要删除的entry数量</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; p[<span class="number">0</span>] != ZIP_END &amp;&amp; i &lt; num; i++) &#123;</span><br><span class="line">        p += zipRawEntryLength(p);</span><br><span class="line">        deleted++;</span><br><span class="line">    &#125;</span><br><span class="line">    totlen = p-first.p;<span class="comment">//代表要删除的总的entry的字节数</span></span><br><span class="line">    <span class="keyword">if</span> (totlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            <span class="comment">//关键部分，删除后，更新要p对应的entry的prelen，使其要与first对应的prelen一致</span></span><br><span class="line">            nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);</span><br><span class="line">            p -= nextdiff;</span><br><span class="line">            zipPrevEncodeLength(p,first.prevrawlen);</span><br><span class="line">            <span class="comment">//更新zltail，此时长度应减去totlen</span></span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen);</span><br><span class="line">            <span class="comment">//若p不是最后一个entry，则要对tail的特殊处理</span></span><br><span class="line">            tail = zipEntry(p);</span><br><span class="line">            <span class="keyword">if</span> (p[tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">                ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                   intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将p后面的entry直接“拼接”到frist后面</span></span><br><span class="line">            memmove(first.p,p,</span><br><span class="line">                intrev32ifbe(ZIPLIST_BYTES(zl))-(p-zl)<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">            <span class="comment">//直接删去，不需要拼接，只需要修改zltail</span></span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe((first.p-zl)-first.prevrawlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改zllen，重新结尾填充0xFF</span></span><br><span class="line">        offset = first.p-zl;</span><br><span class="line">        zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl))-totlen+nextdiff);</span><br><span class="line">        ZIPLIST_INCR_LENGTH(zl,-deleted);</span><br><span class="line">        p = zl+offset;</span><br><span class="line">        <span class="comment">//连锁更新</span></span><br><span class="line">        <span class="keyword">if</span> (nextdiff != <span class="number">0</span>)</span><br><span class="line">            zl = __ziplistCascadeUpdate(zl,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/ziplist.bmp"></p>
<p>__ziplistDelete()实现对ziplist从指定p指向的entry处删除num个entry的操作。</p>
<p>删除的关键在于头尾的处理，如图所示，由于p所指的entry和first的prelen的编码长度可能不一致，所以需要将p进行偏移，偏移量正好是两个prelen编码长度之差。同时如图所示，由于我们要将中间部分去掉，首先zltail应减去待删除的长度。若此时p刚好是整个ziplist的最后一个entry，将它拼接到first后面，zltail的值应当始终为first；若p指向的entry后面还有其他的entry，那么此时最后一个entry的偏移量应当在zltail减去了totlen基础上加上nextdiff。然后是对zllen的更新，zl的重新分配内存，同时要对ziplist的最后一个字节填充0xFF。最后当存在nextdiff时，要进行连锁式更新。对于连锁式更新，我们在接下来章节会进行介绍。</p>
<h3 id="5，插入entry"><a href="#5，插入entry" class="headerlink" title="5，插入entry"></a>5，插入entry</h3><p>将entry插入到zl中p指向的entry处，ziplistInsert()内部是通过调用__ziplistInsert()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistInsert</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">char</span> *s, <span class="type">unsigned</span> <span class="type">int</span> slen)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> *__ziplistInsert(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">char</span> *s, <span class="type">unsigned</span> <span class="type">int</span> slen) &#123;</span><br><span class="line">    <span class="type">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line">    <span class="type">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encoding = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> value = <span class="number">123456789</span>; </span><br><span class="line">    zlentry tail;</span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            prevlen = zipRawEntryLength(ptail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line">        reqlen = zipIntSize(encoding);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reqlen = slen;</span><br><span class="line">    &#125;</span><br><span class="line">    reqlen += zipPrevEncodeLength(<span class="literal">NULL</span>,prevlen);</span><br><span class="line">    reqlen += zipEncodeLength(<span class="literal">NULL</span>,encoding,slen);</span><br><span class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;</span><br><span class="line">    offset = p-zl;</span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class="line">    p = zl+offset;</span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff);</span><br><span class="line">        zipPrevEncodeLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class="line">        tail = zipEntry(p+reqlen);</span><br><span class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">        offset = p-zl;</span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;</span><br><span class="line">    p += zipPrevEncodeLength(p,prevlen);</span><br><span class="line">    p += zipEncodeLength(p,encoding,slen);</span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,s,slen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入与删除类似，步骤如下：</p>
<p>(1)，首先是要确定插入位置的前一个entry的长度，若插入的是最后一个entry，直接用ziplist的zltail找到最后一个entry并找到这个entry的长度；若插入的不是最后一个entry，ZIP_DECODE_PREVLEN()宏直接用这个entry的prelen参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">       ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="type">unsigned</span> <span class="type">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">       <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">           prevlen = zipRawEntryLength(ptail);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/step1.bmp"></p>
<p>(2)，接着是对该entry本身编码，若该entry可编码成整型数，则按照entry介绍的几种整数编码；若不能则按照字符串进行编码。然后计算entry长度的编码的长度和prelen的编码的长度，这样将三者相加，即可得到实际插入进ziplist中entry的大小reqlen。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line">        reqlen = zipIntSize(encoding);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reqlen = slen;</span><br><span class="line">    &#125;</span><br><span class="line">reqlen += zipPrevEncodeLength(<span class="literal">NULL</span>,prevlen);</span><br><span class="line">reqlen += zipEncodeLength(<span class="literal">NULL</span>,encoding,slen);</span><br></pre></td></tr></table></figure>

<p>(3)，如果要插入的位置后面还有entry，需要计算nextdiff以使得后面的entry在记录待插入的entry的时候有足够的空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">zipPrevLenByteDiff</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevlensize;</span><br><span class="line">    ZIP_DECODE_PREVLENSIZE(p, prevlensize);</span><br><span class="line">    <span class="keyword">return</span> zipPrevEncodeLength(<span class="literal">NULL</span>, len) - prevlensize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4)，对ziplist调用zrealloc()重新分配内存，新的内存大小在原来的基础上加上reqlen和nextdiff，此时zl的值可能会发生改变，所以要记录下插入位置的偏移量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">offset = p-zl;</span><br><span class="line">zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class="line">p = zl+offset;</span><br></pre></td></tr></table></figure>

<p>(5)，将插入位置后面的entry（如果存在）拷贝到新的内存空间上正确的位置，更新下个entry的prelen，并更新ziplist的zltail。如图所示，要将原先p-nextdiff位置对应到下面红色方框处，拷贝长度即时从p-nextdiff到实线框结尾。</p>
<p><img src="/images/step4.bmp"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">    memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff);</span><br><span class="line">    zipPrevEncodeLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">        intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class="line">    tail = zipEntry(p+reqlen);</span><br><span class="line">    <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(6) ，若nextdiff不为0，则需要进行连锁式更新</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">       offset = p-zl;</span><br><span class="line">       zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">       p = zl+offset;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>(7)，处理完后面的entry后，最后是将待插入的entry真正地写入。在p处首先写入header，分别是prelen和rawlen，然后写入编码后的字符串或整数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p += zipPrevEncodeLength(p,prevlen);</span><br><span class="line">p += zipEncodeLength(p,encoding,slen);</span><br><span class="line"> <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">     <span class="built_in">memcpy</span>(p,s,slen);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     zipSaveInteger(p,value,encoding);</span><br><span class="line"> &#125;</span><br><span class="line"> ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="6，连锁式更新"><a href="#6，连锁式更新" class="headerlink" title="6，连锁式更新"></a>6，连锁式更新</h3><p>在前面的分析中，存在一种称为连锁式更新的现象：当插入新的entry时，当前entry现有的prelen字段无法表示上个entry的大小，需要对prelen进行重新的编码，这样的操作可能会造成当前entry自身的大小发生变化，我们便需要计算下个entry的prelen，重新编码…整个迭代过程直到entry的大小不再发生变化停止，也就是nextdiff为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> *__ziplistCascadeUpdate(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">char</span> *p) &#123;</span><br><span class="line">    <span class="type">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;</span><br><span class="line">    <span class="type">size_t</span> offset, noffset, extra;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *np;</span><br><span class="line">    zlentry cur, next;</span><br><span class="line">    <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        cur = zipEntry(p);</span><br><span class="line">        rawlen = cur.headersize + cur.len;</span><br><span class="line">        rawlensize = zipPrevEncodeLength(<span class="literal">NULL</span>,rawlen);</span><br><span class="line">        <span class="keyword">if</span> (p[rawlen] == ZIP_END) <span class="keyword">break</span>;</span><br><span class="line">        next = zipEntry(p+rawlen);</span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlen == rawlen) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlensize &lt; rawlensize) &#123;</span><br><span class="line">            offset = p-zl;</span><br><span class="line">            extra = rawlensize-next.prevrawlensize;</span><br><span class="line">            zl = ziplistResize(zl,curlen+extra);</span><br><span class="line">            p = zl+offset;</span><br><span class="line">            np = p+rawlen;</span><br><span class="line">            noffset = np-zl;</span><br><span class="line">           <span class="keyword">if</span> ((zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) &#123;</span><br><span class="line">                ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra);</span><br><span class="line">            &#125;</span><br><span class="line">          memmove(np+rawlensize,</span><br><span class="line">                np+next.prevrawlensize,</span><br><span class="line">                curlen-noffset-next.prevrawlensize<span class="number">-1</span>);</span><br><span class="line">            zipPrevEncodeLength(np,rawlen);</span><br><span class="line">            p += rawlen;</span><br><span class="line">            curlen += extra;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (next.prevrawlensize &gt; rawlensize) &#123;</span><br><span class="line">              zipPrevEncodeLengthForceLarge(p+rawlen,rawlen);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                zipPrevEncodeLength(p+rawlen,rawlen);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(1)，计算当前entry和下个entry,并判断是否达到终止条件：已经是最后一个entry；下个entry的prelen刚好等于当前entry的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cur = zipEntry(p);</span><br><span class="line">   rawlen = cur.headersize + cur.len;</span><br><span class="line">   rawlensize = zipPrevEncodeLength(<span class="literal">NULL</span>,rawlen);</span><br><span class="line">   <span class="keyword">if</span> (p[rawlen] == ZIP_END) <span class="keyword">break</span>;</span><br><span class="line">   next = zipEntry(p+rawlen);</span><br><span class="line">   <span class="keyword">if</span> (next.prevrawlen == rawlen) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>(2)，下面讨论三种情况：情况1，下个entry的prelen字段的大小不足够表示当前entry长度，需要扩充prelen字段大小 。处理方式和插入部分处理类似，首先计算出next entry增加的长度，并对ziplist进行扩容；若next entry不是最后一个entry，则要修改ziplist的zltail字段；接着开始将next entry拷贝到正确的位置，对next entry的prelen重新编码以正确反映当前entry的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if (next.prevrawlensize &lt; rawlensize) &#123;//情况1</span><br><span class="line">            offset = p-zl;</span><br><span class="line">            extra = rawlensize-next.prevrawlensize;</span><br><span class="line">            zl = ziplistResize(zl,curlen+extra);</span><br><span class="line">            p = zl+offset;</span><br><span class="line">            np = p+rawlen;</span><br><span class="line">            noffset = np-zl;</span><br><span class="line">           if ((zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) &#123;</span><br><span class="line">                ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra);</span><br><span class="line">            &#125;</span><br><span class="line">          memmove(np+rawlensize,</span><br><span class="line">                np+next.prevrawlensize,</span><br><span class="line">                curlen-noffset-next.prevrawlensize-1);</span><br><span class="line">            zipPrevEncodeLength(np,rawlen);</span><br><span class="line">            p += rawlen;</span><br><span class="line">            curlen += extra;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>2，下个entry的prelen字段大小足够表示当前entry长度且还有空余，需要压缩prelen字段大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (next.prevrawlensize &gt; rawlensize) &#123;</span><br><span class="line">              zipPrevEncodeLengthForceLarge(p+rawlen,rawlen);</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<p> 3，下个entry的prelen字段的大小刚好足够表示当前entry长度，此时只需要对next entry的prelen字段重新编码，无需扩充和压缩空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                zipPrevEncodeLength(p+rawlen,rawlen);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h3 id="7，下标搜索"><a href="#7，下标搜索" class="headerlink" title="7，下标搜索"></a>7，下标搜索</h3><p>  对ziplist指定的第index个entry(从零开始),返回对应的entry指针；若index为正，则是从头开始往尾，若index为－，则是从最后一个entry往前计算，若ziplist不包含entry，则返回NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistIndex</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;<span class="comment">//负数，从尾向头</span></span><br><span class="line">        index = (-index)<span class="number">-1</span>;</span><br><span class="line">        p = ZIPLIST_ENTRY_TAIL(zl);<span class="comment">//最后一个entry</span></span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);<span class="comment">//计算出前一个entry的长度</span></span><br><span class="line">            <span class="keyword">while</span> (prevlen &gt; <span class="number">0</span> &amp;&amp; index--) &#123;<span class="comment">//迭代直到找到对应下标的entry或已经是头</span></span><br><span class="line">                p -= prevlen;</span><br><span class="line">                ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//正数，从头到尾</span></span><br><span class="line">        p = ZIPLIST_ENTRY_HEAD(zl);<span class="comment">//第一个entry</span></span><br><span class="line">        <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END &amp;&amp; index--) &#123;<span class="comment">//迭代直到找到对应下标的entry或已经是尾</span></span><br><span class="line">            p += zipRawEntryLength(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (p[<span class="number">0</span>] == ZIP_END || index &gt; <span class="number">0</span>) ? <span class="literal">NULL</span> : p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>参考:</strong>  <a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/unstable/src/ziplist.c">https://github.com/redis/redis/blob/unstable/src/ziplist.c</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/posts/42240f40.html" rel="next" title="redis之ziplist">
      redis之ziplist <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%EF%BC%8C%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">一，概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%EF%BC%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">二，基本结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#zlbytes"><span class="nav-number">2.1.</span> <span class="nav-text">zlbytes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zltail"><span class="nav-number">2.2.</span> <span class="nav-text">zltail</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zllen"><span class="nav-number">2.3.</span> <span class="nav-text">zllen</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zlend"><span class="nav-number">2.4.</span> <span class="nav-text">zlend</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#entry"><span class="nav-number">2.5.</span> <span class="nav-text">entry</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%EF%BC%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">三，源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%8C%E7%BC%96%E7%A0%81%E7%9B%B8%E5%85%B3"><span class="nav-number">3.1.</span> <span class="nav-text">1，编码相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%8C%E8%A7%A3%E7%A0%81%E7%9B%B8%E5%85%B3"><span class="nav-number">3.2.</span> <span class="nav-text">2，解码相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%8C%E5%88%9B%E5%BB%BAziplist"><span class="nav-number">3.3.</span> <span class="nav-text">3，创建ziplist</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%8C%E5%88%A0%E9%99%A4ziplist"><span class="nav-number">3.4.</span> <span class="nav-text">4，删除ziplist</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%8C%E6%8F%92%E5%85%A5entry"><span class="nav-number">3.5.</span> <span class="nav-text">5，插入entry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%EF%BC%8C%E8%BF%9E%E9%94%81%E5%BC%8F%E6%9B%B4%E6%96%B0"><span class="nav-number">3.6.</span> <span class="nav-text">6，连锁式更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%EF%BC%8C%E4%B8%8B%E6%A0%87%E6%90%9C%E7%B4%A2"><span class="nav-number">3.7.</span> <span class="nav-text">7，下标搜索</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wanbess</p>
  <div class="site-description" itemprop="description">Do not go gentle into that good night</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wanbess</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
